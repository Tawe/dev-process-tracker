# How GitHub Copilot CLI Was Used

This file is intended for challenge judges and documents practical usage of GitHub Copilot CLI while building Dev Process Tracker.

## Project Context

- Project: `devpt` (Go CLI + TUI for local dev server management)
- Primary stack: Go, Bubble Tea, Lipgloss
- Scope: process discovery, registry management, service lifecycle, logs, and health/status inspection

## Copilot CLI Contribution Log

Concrete examples used during this project:

| Date (PT) | Task | Copilot CLI prompt/example | Output summary | What I changed after |
|---|---|---|---|---|
| 2026-02-14 | Validate managed command input | `gh copilot suggest "add command validation for managed service commands and include tests for blocked patterns"` | Suggested a validation helper with pattern checks and table-driven tests | Tightened blocked command cases, aligned error messages with CLI conventions, and simplified test names |
| 2026-02-14 | Clarify TUI key behavior | `gh copilot explain pkg/cli/tui.go` | Provided a walkthrough of key handling flow and likely conflict points | Kept existing update model, but adjusted help/command hints and retained only low-risk behavior changes |
| 2026-02-15 | Improve crash visibility in status output | `gh copilot suggest "show crash reason and recent log tail in status command for crashed services"` | Proposed adding crash details section and inferred reason output | Refined wording and formatting to match the rest of CLI output and removed noisy lines |
| 2026-02-15 | Expand boundary tests | `gh copilot suggest "edge-case tests for parse command args with quotes and whitespace"` | Generated a first-pass set of parse edge cases | Removed redundant cases, rewrote assertions for existing behavior, and kept only maintainable scenarios |

## High-Value Workflows Used

1. **Codebase understanding**
   - Used Copilot CLI to summarize unfamiliar files before editing.
   - Helped reduce onboarding time for larger files in `pkg/cli` and `pkg/process`.

2. **Drafting implementation**
   - Used Copilot CLI to generate first-pass code for focused features.
   - Final implementations were manually reviewed and adjusted for project conventions.

3. **Test generation and edge-case checks**
   - Used Copilot CLI to propose table-driven tests and boundary cases.
   - Accepted only tests aligned with current behavior and naming patterns.

## Verification Notes

- All AI-generated suggestions were reviewed before commit.
- Changes were validated with `go test ./...`.
- Project-specific conventions were enforced manually (error messages, command patterns, state handling).

## Human Review Examples (AI Output Was Edited)

1. Validation logic generated by Copilot was narrowed to project-safe patterns and clearer user-facing errors.
2. Suggested TUI refactors were partially rejected to avoid regressions in state transitions.
3. Crash output drafts were reformatted for consistent headers and less noisy logs.
4. Test scaffolds were reduced to focused, behavior-driven cases rather than broad generated coverage.

## Optional Evidence to Include in Submission Post

- Terminal screenshots showing Copilot CLI prompts and follow-up iterations
- Before/after snippet for one feature where Copilot CLI accelerated implementation
- Commit links highlighting where suggestions were adapted
